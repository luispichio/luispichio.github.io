<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <div class="separator" style="clear: both; text-align: center;"> </div> <p>  Buenas!<br>   Navegando en viejos almacenes de demoscene, dí con un proyecto que me llamó poderosamente la atención: <a href="http://www.linusakesson.net/scene/craft/index.php" target="_blank" rel="external nofollow noopener">Craft</a> de Linus Åkesson; Una obra de arte en miniatura basada en un ATmega88 que genera señales de VGA, los efectos y hasta sonido!<br>   El hallazgo coincidió con el recién adquirido clon chino de Arduino Mega 2560 y con mis ganas de generar contenido para el blog así que… ¿Porqué no hacer una librería para generar señales de VGA con hardware estándar?<br> <br> <b><span style="font-size: large;">Manos a la obra</span></b><br></p> <div>   Empezaré con una introducción teórica, para luego discutir la implementación, el hardware y por último el software asociado (librería).<br> <br> </div> <div class="separator" style="clear: both; text-align: center;"> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjj_b3VZYBYGPUZYpQ6cNnPGj41a1Ces12QGbl0pTHi7tuNKxw6f76WfFGgyppV6KmRJ1M5HY_kOnwYuwJKk3u994KTdkn5Y3SYaSo8iG2qSYHMXTwqZK1Zk9jRFwlvFy84Dj-A6Vi67Yw_/s1600/Collage.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="480" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjj_b3VZYBYGPUZYpQ6cNnPGj41a1Ces12QGbl0pTHi7tuNKxw6f76WfFGgyppV6KmRJ1M5HY_kOnwYuwJKk3u994KTdkn5Y3SYaSo8iG2qSYHMXTwqZK1Zk9jRFwlvFy84Dj-A6Vi67Yw_/s640/Collage.jpg" width="640"></a> </div> <p><br> <b><span style="font-size: large;">Introducción Teórica</span></b><br> <br> <span style="color: red;">  Se hace referencia a continuación a los tubos de rayos catódicos (monitor de vidrio), cuando los mismos están prácticamente en desuso, reemplazados por pantallas LCD / LED. De todas formas, a nivel eléctrico el estándar se ha mantenido y lo que hacen los monitores modernos es “emular” el comportamiento de un crt para mantener la compatibilidad.</span><br> <br> <b>Funcionamiento de un monitor VGA</b><br>   A groso modo un monitor o tubo de rayos catódicos (crt) es un tubo al vacío de vidrio con una película de fósforo en la parte frontal (pantalla) sobre la que se hace incidir un haz de rayos catódicos.<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiWoVigTkU5hBl2zb0_RWuF5Tn8mXdfgIyqufBULP6mSWrupRhBQ_09uFsqG8_6whyphenhyphenl77ggp57YBkYbtNg0t-mYOjLthoRJbYKZgkTxIj-cLkY7shr1uo2avTUSqd_YCdWLbf40xYbERBNH/s1600/crt.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="278" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiWoVigTkU5hBl2zb0_RWuF5Tn8mXdfgIyqufBULP6mSWrupRhBQ_09uFsqG8_6whyphenhyphenl77ggp57YBkYbtNg0t-mYOjLthoRJbYKZgkTxIj-cLkY7shr1uo2avTUSqd_YCdWLbf40xYbERBNH/s400/crt.png" width="400"></a> </div> <p><br>   El haz (o los múltiples haces), que “recorre” (barre) constantemente la pantalla de izquierda a derecha y de arriba a abajo (normalmente) al incidir sobre la película de fósforo genera un punto iluminado (pixel) que conforma la imagen mostrada en la pantalla.<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhQWG868sx_VarO_tf1TNZhSWuaB095fSdkdXPF6C5ZLWVRaoWGs0h58931b7HFdSPfn-Ij0ou_ASaODSHYTkLjj2Wms0dy0mbwj7pl5wwoX9MRE2WPPFLDb0ei_nvO8-j-N1RM7gH5EDPt/s1600/barrido.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="286" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhQWG868sx_VarO_tf1TNZhSWuaB095fSdkdXPF6C5ZLWVRaoWGs0h58931b7HFdSPfn-Ij0ou_ASaODSHYTkLjj2Wms0dy0mbwj7pl5wwoX9MRE2WPPFLDb0ei_nvO8-j-N1RM7gH5EDPt/s400/barrido.jpg" width="400"></a> </div> <p><br>   El movimiento de barrido del haz se realiza por medio de los llamados deflectores.<br>   El control de deflexión y cañón es manejado, en el caso de un monitor VGA por 5 señales eléctricas (5 pines + tierra del DB15 del monitor):<br>   <u>Sincronización Horizontal (H-SYNC):</u> Señal digital (pulso 0 - 5V)  asociada al deflector vertical del crt (o a su equivalente en un led / lcd) que marca el inicio de una línea, determina la resolución horizontal y asegura que el monitor muestre los pixeles de la misma entre los margenes izquierdo y derecho del área visible de la pantalla.<br>   <u>Sincronización Vertical (V-SYNC):</u> Señal digital (pulso 0 - 5V) asociada al deflector vertical del crt (o a su equivalente en un led / lcd) que marca el inicio de un “frame”, determina la resolución vertical y asegura que las líneas horizontales estén entre el margen superior y inferior del área visible de la pantalla.<br>   <u>R, G, B:</u> Señales analógicas en el rango 0V (oscuro) a 0.7V (máxima intensidad) asociadas al cañón de electrones del crt (o a su equivalente en un led / lcd) que controlan la intensidad de cada componente de color que combinados conforman el color pixel a pixel, linea a linea de la pantalla.<br> <br></p> <div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz0zYhRKvnU_Y3lWy6s70qJ6SuFQSgvNr_5p_La8LF7fLxQl7yg-cbYVnHffkQ3HpLzZsH43aCsfWoqZcm01JZHydnmzixEqNWPwRLoaYaAbJFMtDn-SEwdCxQ8lb6zexwUDCovlLigCY9/s1600/DB15.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="170" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz0zYhRKvnU_Y3lWy6s70qJ6SuFQSgvNr_5p_La8LF7fLxQl7yg-cbYVnHffkQ3HpLzZsH43aCsfWoqZcm01JZHydnmzixEqNWPwRLoaYaAbJFMtDn-SEwdCxQ8lb6zexwUDCovlLigCY9/s200/DB15.png" width="200"></a> </div> <br>   El estándar es muy estricto en cuanto a los tiempos de las formas de onda. Cualquier variación genera deformaciones, parpadeos, problemas de alineación, etc.<br>   Cada modo de los muy variados tiene tu respectivo diagramas de tiempo; Para mas información consultar <a href="http://martin.hinner.info/vga/timing.html" target="_blank" rel="external nofollow noopener">VGA Timings</a>.<br>   A continuación diagramas / tablas de formas de onda y tiempos del modo VGA 640 x 480 x 60hz.<br> <br> </div> <p><b>Diagrama de tiempos simplificado para el modo VGA 640x480 60hz</b><br> <b><br></b> <br></p> <div class="separator" style="clear: both; text-align: center;"> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPakql528eozFMrUNCOiexXr-Yq18J-0ZRLbNPBHf-PcQuumEbwqh2bE5aLs98SeU49zvUzyICQmYyChIFolvRWPtAJo3kozdTklIsugW4mNw7SZd-Fw2cC9bxN0ztjs4n5oQSv6WWcxK5/s1600/VGA+-+Timing+(1).png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="465" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgPakql528eozFMrUNCOiexXr-Yq18J-0ZRLbNPBHf-PcQuumEbwqh2bE5aLs98SeU49zvUzyICQmYyChIFolvRWPtAJo3kozdTklIsugW4mNw7SZd-Fw2cC9bxN0ztjs4n5oQSv6WWcxK5/s640/VGA+-+Timing+(1).png" width="640"></a> </div> <p><br></p> <div class="separator" style="clear: both; text-align: left;"> <b>Tabla de tiempos</b> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqRcAIg2qnOWV6daNmM4-weh7cDkHneAUakfe6yR7CFKEhzw4Kd0JLWmf6ZD2J7iDfdzaSbgPx5-n2rs87jl4OIGrnWohQnWD4kxWcnQIDcdgMTL2c07XTtahgxcQ3CNIofPsZk5mvL4G9/s1600/VGA+-+Timing+(3).png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="400" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqRcAIg2qnOWV6daNmM4-weh7cDkHneAUakfe6yR7CFKEhzw4Kd0JLWmf6ZD2J7iDfdzaSbgPx5-n2rs87jl4OIGrnWohQnWD4kxWcnQIDcdgMTL2c07XTtahgxcQ3CNIofPsZk5mvL4G9/s400/VGA+-+Timing+(3).png" width="393"></a> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqRcAIg2qnOWV6daNmM4-weh7cDkHneAUakfe6yR7CFKEhzw4Kd0JLWmf6ZD2J7iDfdzaSbgPx5-n2rs87jl4OIGrnWohQnWD4kxWcnQIDcdgMTL2c07XTtahgxcQ3CNIofPsZk5mvL4G9/s1600/VGA+-+Timing+(3).png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><br></a> </div> <div style="text-align: left;"> <b><br></b> </div> <div style="text-align: left;"> <b>Representación gráfica alternativa</b><br> <b><br></b> </div> <div style="text-align: left;"> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiqu6CKINPqyEsswvy4RdbJ_Hwj_VUzBENs0hzfwHKHwyZWMr4N8ssjfwuZ32H8N-2DrWJ1aRwSeAd5l24NCxQeiHaFFV1pMt_TtX2gdoJSXzmtZg6wXKZTnF5fpDfImR8taGdzOiK9K8lL/s1600/VGA+-+Timing+(2).png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="513" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiqu6CKINPqyEsswvy4RdbJ_Hwj_VUzBENs0hzfwHKHwyZWMr4N8ssjfwuZ32H8N-2DrWJ1aRwSeAd5l24NCxQeiHaFFV1pMt_TtX2gdoJSXzmtZg6wXKZTnF5fpDfImR8taGdzOiK9K8lL/s640/VGA+-+Timing+(2).png" width="640"></a> </div> </div> <p><b><br></b> <b><span style="font-size: large;">Análisis de Implementación</span></b><br> <br>   ¿Porqué 640x480? Primero es el más estándar de los modos (introducido por IBM para las PS/2 por el año 1987). Segundo es el de menor resolución y por ende el mas “alcanzable”. 320x200 y 320 x240 son variantes del 640x480 y 640x400 (cuatro pixeles por pixel) y no hay beneficios para la implementación.<br>   El primer escollo de la implementación tienen que ver con la frecuencia de reloj del los pixeles: 25.175mhz.<br>   ¿Que es este valor? La frecuencia (velocidad) a la que deben variar las señales analógicas de los 3 componentes de color (R, G y B) para conseguir la resolución horizontal de 640 pixeles.<br>   Demás está decir que esa frecuencia de reloj es inalcanzable con hardware estándar (Arduino basado en microcontrolador de familia ATmega).<br>   Para nuestro caso en particular, utilizando DAC’s de escaleras de resistencias (se explicará posteriormente), la frecuencia máxima alcanzable será de 16mhz / 3 (ciclos de instrucción por pixel) ~5,3mhz. La máxima resolución alcanzable con esta configuración será de ~135pixeles en ancho por 480 líneas de alto (sin límites).<br>   Se plantea una alternativa para el modo monocromático utilizando el puerto serial de controlador para generar las señales. En este caso la frecuencia máxima alcanzable será de 16mhz / 2 (máxima frecuencia del usart) = 8mhz. La máxima resolución alcanzable con esta configuración será de ~203pixeles en ancho por 480 líneas de alto.<br>   Con reloj de 20mhz (en algunos casos viene / se puede reemplazar) mejorará levemente el rendimiento y se podrá subir ligeramente la resolución.<br>   La utilización con reloj de 8mhz queda directamente descartada.<br> <br> <b><span style="font-size: large;">Implementación</span></b><br> <br> <b>Circuito</b><br>   Se plantean dos circuitos diferentes para la generación de color en los modos color y monocromático.<br> <br> <b>VGA Color</b><br>   Como mencionaba anteriormente, para los niveles de RGB es necesario generar señales analógicas en el rango [0V - 0.7V].<br>   Como primera medida, la familia de microcontroladores AVR ATmega de Atmel carecen de DAC’s; pero aún si los tuvieran, se requiere de una frecuencia según especificación de 25.175 mhz (en criollo, el DAC tiene que ser capaz de “cambiar de valor” 25 millones de veces por segundo), lo que directamente escapa a controladores de gama baja / media, independientemente de la marca.<br>   Utilizaré entonces los clásicos y conocidos DAC’s conformados por resistencias en escalera (<a href="http://es.wikipedia.org/wiki/Red_R-2R" rel="external nofollow noopener" target="_blank">http://es.wikipedia.org/wiki/Red_R-2R</a>).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh_kFaLy7AWyBT5WKB06gYtLt2_ComDwQx6RI8a5s33JdBMNJOtVaOeonagUKGjhCgzselLmgwfjyeaZHcsZhVOdEaXF_f9fRFqI4H7ZtEirLfVdFCXf5tDwxtbwM7XkZGTaRWLVGcXef_9/s1600/420px-R2r-ladder.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="100" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh_kFaLy7AWyBT5WKB06gYtLt2_ComDwQx6RI8a5s33JdBMNJOtVaOeonagUKGjhCgzselLmgwfjyeaZHcsZhVOdEaXF_f9fRFqI4H7ZtEirLfVdFCXf5tDwxtbwM7XkZGTaRWLVGcXef_9/s400/420px-R2r-ladder.png" width="400"></a> </div> <p><br>   Este tipo de topología es probablemente la forma mas simple y económica de construir un DAC para generar una señal analógica (Vout) a partir de los datos digitales del puerto digital al que las resistencias estén conectadas (a(0) .. a(n-1)),<br>   Para nuestro caso usaremos 2 redes de 3 bits para los componentes rojo / verde y una de 2 bits para los componentes azules.<br>   Pueden generarse entonces 8 niveles de rojo / verde y 4 de azul siendo la máxima cantidad de colores representables 8 * 8 * 4 = 256 (<a href="http://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_palettes#3-3-2_bit_RGB" target="_blank" rel="external nofollow noopener">RGB 3-3-2</a>).<br>   En el esquema se utilizan las E/S digitales [22 - 29] (corresponden al PORTA del microcontrolador) para los DAC en escalera de los componentes de color y PWM [12, 13] para las señales de sincronismo. El puerto utilizado puede modificarse desde el include de configuración de la librería (ArduinoVGAConfig.h).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjoNLu_Ty4TqSrJbbhL9RvF5Jvz3V7Im7paZP-iiXf4ySe_D6yznOpFAmbcW7oqyACPk8kqO0bNN-tZvIGOtPCR_P0SyTfByrExcS7jdc9_BzjpGHhP8BiGvmbtPJuDbtMT3UkD9xSFZ7V8/s1600/Arduino+VGA+-+Circuit+(Color).png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="265" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjoNLu_Ty4TqSrJbbhL9RvF5Jvz3V7Im7paZP-iiXf4ySe_D6yznOpFAmbcW7oqyACPk8kqO0bNN-tZvIGOtPCR_P0SyTfByrExcS7jdc9_BzjpGHhP8BiGvmbtPJuDbtMT3UkD9xSFZ7V8/s640/Arduino+VGA+-+Circuit+(Color).png" width="640"></a> </div> <p><br>   R4, R9 y R16: Están contempladas para el caso de que algún monitor no tenga los 75ohms según especificación, en cuyo caso, se necesitarían para “compensar” ya que el cálculo del DAC ladder es para esa impedancia de carga.<br> <br> <b>VGA Monocromático</b><br> <b><br></b>   El circuito para el modo monocromático (blanco y negro) es bastante mas sencillo. A diferencia del circuito para generación de VGA color se necesitan solo dos niveles de color (dos estados), blanco y negro. El negro se obtiene a partir de la aplicación de 0V en cada uno de los canales de color.<br> El blanco a partir de la aplicación de 0.7V (intensidad máxima) en cada uno de los canales.<br>   Requiere de muy pocos componentes y puede ser construido en protoboard o directamente dentro de las “tapitas” del conector DB15.<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgiJWSofqwJOar7N47mzzuR5VfwtwIpDw4h40QPLQoHkehyphenhyphenaGBWQZuwQUphuQdIym-oePRZo9rHY0ccad7XBVZ4BeC-xjaMnn9Y5iIhcRNkyXCo7NDn6_jKSCdhHaU3TYYGec23RWTczrgp/s1600/Arduino+VGA+-+Circuit+%2528B%2526W%2529.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="472" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgiJWSofqwJOar7N47mzzuR5VfwtwIpDw4h40QPLQoHkehyphenhyphenaGBWQZuwQUphuQdIym-oePRZo9rHY0ccad7XBVZ4BeC-xjaMnn9Y5iIhcRNkyXCo7NDn6_jKSCdhHaU3TYYGec23RWTczrgp/s640/Arduino+VGA+-+Circuit+%2528B%2526W%2529.png" width="640"></a> </div> <p><br>   Cuenta con solo 5 resistencias de las cuales son 3 las estrictamente necesarias (R1, R2 y R3).<br> R1, R2 y R3 están calculadas para generar una caída de tensión de ~0.7V en la resistencia interna del monitor (75ohms).<br>   R4 y R5 son limitadoras de corriente con la finalidad de proteger el puerto del controlador del Arduino ante cualquier eventualidad.<br>   En el esquema se utiliza la E/S digital 18 (TX del USART1 del microcontrolador) para los componentes de color, PWM [12, 13] para las señales de sincronismo y tierra (se puede usar cualquiera). Los puertos utilizados puede modificarse desde el include de configuración de la librería (ArduinoVGAConfig.h).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiZX0nAdqtkeixYO8KiyVkD4CgqBqs_JRORHnHNeAiN1jmuGGMFlBCekFUpY7-mGppXTPNkxh7CtE17rGWmMriyjuFcsuZNFIL3D87rPYMOmRowrM_reDwSoU6CdEYnron5gB-eAJUeKFb3/s1600/b%2526w+%2528Small%2529.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="300" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiZX0nAdqtkeixYO8KiyVkD4CgqBqs_JRORHnHNeAiN1jmuGGMFlBCekFUpY7-mGppXTPNkxh7CtE17rGWmMriyjuFcsuZNFIL3D87rPYMOmRowrM_reDwSoU6CdEYnron5gB-eAJUeKFb3/s400/b%2526w+%2528Small%2529.jpg" width="400"></a> </div> <p><br> <b><span style="font-size: large;">Software</span></b><br>   A nivel software se deben generar por una lado las señales de sincronismo, las de video y proveer al usuario de una interfaz (clase pública) con rutinas que permitan modificar el contenido de la pantalla.<br> <br> <b>Señales de sincronismo</b><br> <br>   Las señales de sincronismo deben ser generadas con la mayor exactitud / precisión posible.<br>   Utilizaré para ello uno de los Timers de 16bits de la familia de microcontroladores ATmega.<br>   El timer es un periférico de hardware accesible desde el código vía registros capaz de ejecutar rutinas cada intervalos específicos (interrupción), medir tiempos y generar formas de onda.<br> <br>   A partir del Timer se generará:<br>     Interrupción cada 31,8uS (horizontal)<br>     Pulso de sincronismo horizontal de 3.8uS generado por módulo Ouput Compare del Timer<br>     Señal de video<br>     Pulso de sincronismo vertical generado desde la interrupción<br> <br> <b>Memoria de video</b><br>   Espacio de memoria RAM asignado como buffer intermedio entre la interfaz de usuario (clase pública) y la librería de generación de señales de bajo nivel.<br>   Las funciones gráficas de la librería de control vuelcan contenido sobre la memoria de video.<br>   La sección de bajo nivel de la librería, a la tasa de refresco correspondiente con el modo (60hz), vuelca el contenido en la pantalla crt (genera las formas de onda acorde al contenido).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLeZ92TheMo6jGtOibx161WgmcUH_ENfx2R_BCjTAX6oqv_YAKoGPpToLl-hCSo2ixtdE-uAzpOWXzgPk776jioZOJ1jIYueysifh0YS2cNCFp4dMtPvoq_Ewyd7yliIXddSdwpzPy_EIq/s1600/Arduino+VGA+-+Memoria+de+video.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="77" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLeZ92TheMo6jGtOibx161WgmcUH_ENfx2R_BCjTAX6oqv_YAKoGPpToLl-hCSo2ixtdE-uAzpOWXzgPk776jioZOJ1jIYueysifh0YS2cNCFp4dMtPvoq_Ewyd7yliIXddSdwpzPy_EIq/s400/Arduino+VGA+-+Memoria+de+video.png" width="400"></a> </div> <p><br>   Para el modo VGA color se utilizará un byte por pixel.<br>   Para una resolución de 640 x 480 pixeles se requerirían 640*480 = 307200bytes (El Arduino mega2560 cuenta con 8192 bytes de ram); Demás está decir que una de las limitantes del modo color con hardware estándar será entonces la memoria RAM disponible.<br>   En los ejemplos utilizaré una resolución de 64 x 64 = 4096bytes. Estos parámetros podrán modificarse en el include de configuración de la librería (ArduinoVGAConfig.h).<br>   Para el modo VGA monocromático se utilizará un bit por pixel (8 pixeles por byte).<br>   Utilizaré una resolución de 160 x 120 pixeles = 2400bytes. Estos parámetros se podrán modificar también desde el #include de configuración de la librería para permitir su utilización a costas de reducir la resolución en Arduinos de baja gama.<br> <br> <b>Generación de señales de color</b><br>   Propongo dos conjuntos de rutinas para la generación de señales para los dos modos, ambas dentro de la misma librería y configurables por condicionales de compilación (ArduinoVGAConfig.h).<br> <br> <b>VGA Color</b><br> <br>   Para la generación de señales a color utilizaré a nivel software uno de los puertos estándar disponibles en el microcontrolador del Arduino.<br>   En la figura se observa uno de los DAC escalera (componente rojo) conectado a 3 pines de un puerto del microcontrolador.<br>   Los 3 bits en estado bajo corresponderán a una tensión a la salida de la red de 0V (menor intensidad de rojo = negro).<br>   Alternando el estado de los pines del controlador se pueden obtener diferentes niveles de tensión (escalera) hasta alcanzar el máximo de 0.7V (mayor intensidad de rojo).<br>   El mismo esquema se repite para los 3 componentes de color (rojo, verde, azul).<br>   La resistencia de carga de 75ohms corresponde a la impedancia interna del monitor en las líneas de color (R, G, B).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjG7GafOcvXspBBTplQiLXrZveL-eDcArsAGnWkIHkH1cUXJQpc8ZS5AjiT78dFKfMhyNNmb-ofQsyKmnRW5lgX2IMunSXYKJc0o52NxG-RQMbQ547wN45rABl00ZKrFpet_v78kZ0WIqrv/s1600/Arduino+VGA+-+Ladder+output.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="203" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjG7GafOcvXspBBTplQiLXrZveL-eDcArsAGnWkIHkH1cUXJQpc8ZS5AjiT78dFKfMhyNNmb-ofQsyKmnRW5lgX2IMunSXYKJc0o52NxG-RQMbQ547wN45rABl00ZKrFpet_v78kZ0WIqrv/s400/Arduino+VGA+-+Ladder+output.png" width="400"></a> </div> <p><br>   Los componentes de color para el relleno de una línea horizontal se obtienen a partir de alternar tantos bytes por el puerto como pixeles haya de resolución; En nuestro caso, unos 128bytes.<br>   La salida de datos por el puerto por cuestiones de tiempo debe necesariamente de escribirse en ensamblador:<br></p> <hr> <p>//carga en registro el contenido del puntero [Y] (apunta a la memoria de video)<br> //incrementa Y en 1 (siguiente pixel)<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0,Y+  //2 ciclos de reloj<br> //pone en el puerto A el contenido del registro<br> OUT<span class="Apple-tab-span" style="white-space: pre;"> </span>PORTA, R0  // 1 ciclo de reloj<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0,Y+<br> OUT<span class="Apple-tab-span" style="white-space: pre;"> </span>PORTA, R0<br> …<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0,Y+<br> OUT<span class="Apple-tab-span" style="white-space: pre;"> </span>PORTA, R0<br></p> <hr> <p><br> <b>VGA Monocromático</b><br> <br>   Como mencionaba en párrafos anteriores, utilizaré un puerto de comunicaciones USART para generar las formas de onda.<br>   El puerto USART de los controladores ATmega cuentan con las siguientes características interesantes para nuestra aplicación:<br>   (1) Soportan el modo SPI con lo que se eliminan los elementos de sincronismo (start bit, stop bit) de la línea de datos.<br>   (2) Tienen doble buffer de transmisión, que permite “ir cargando” el contenido del segundo byte a transmitir cuando todavía se está transmitiendo el primero (el puerto SPI no puede usarse para esta aplicación por este motivo).<br>   (3) Máximo baudrate soportado: FOSC / 2. Supera ampliamente en frecuencia a la operación sobre puerto estándar.<br> <br>   En la figura se observa el pin de la transmisión del USART conectado a los 3 pines de los componentes de color del monitor VGA.<br>   Las resistencias de 75ohms corresponden a las impedancias internas de cada una de las entradas de color del monitor.<br>   El divisor resistivo formado por cada resistencia de 470ohms y la impedancia interna de 75ohms esta calculado para una caída de tensión de ~0.7V cuando el pin TX del controlador esté en estado alto (1) y de 0V cuando el pin esté en estado bajo (0).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> </div> <div class="separator" style="clear: both; text-align: center;"> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjAEYfW4VZK3ctNg6YuqIy3CxBp8L2m4K8_6PI90E71KPt_c9dBJZHTPtwCmc-iWai1qBnuD_y1jXGIcpQmJo84-pzPMSJaiqX64kMwRr0i2gAnrm32ENPwgihLyG-mJpRQomYkGfdR6713/s1600/Arduino+VGA+-+USART+output.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="97" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjAEYfW4VZK3ctNg6YuqIy3CxBp8L2m4K8_6PI90E71KPt_c9dBJZHTPtwCmc-iWai1qBnuD_y1jXGIcpQmJo84-pzPMSJaiqX64kMwRr0i2gAnrm32ENPwgihLyG-mJpRQomYkGfdR6713/s400/Arduino+VGA+-+USART+output.png" width="400"></a> </div> <p><br>   Los componentes de color para el relleno de una línea horizontal se obtienen a partir de enviar tantos bytes por el puerto serial como pixeles / 8 haya de resolución; En nuestro caso, para 160 bytes corresponden 20 bytes enviados por el USART del controlador.<br>   A 8 pixeles por byte, el color de cada pixel será negro si el bit correspondiente es 0 y blanco (0.7v para Rojo, Verde y Azul) si el bit es 1.<br> <br></p> <div>   La salida de datos por el puerto por cuestiones de tiempo debe necesariamente de escribirse en ensamblador:</div> <hr> <p>//carga en registro el contenido del puntero [Y] (apunta a la memoria de video)<br> //incrementa Y en 1 (siguiente pixel)<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0, Y+<br> //transmite por USART el contenido del registro<br> STS<span class="Apple-tab-span" style="white-space: pre;"> </span><span class="Apple-tab-span" style="white-space: pre;"> </span>UDR1, R0<br> //carga contenido del siguiente pixel<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0, Y+<br> //demora hasta que esté libre el doble buffer para el siguietne byte a transmitir<br> NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP <br> //transmite por USART el contenido del registro<br> STS<span class="Apple-tab-span" style="white-space: pre;"> </span><span class="Apple-tab-span" style="white-space: pre;"> </span>UDR1, R0<br> …<br> LD<span class="Apple-tab-span" style="white-space: pre;"> </span>R0, Y+<br> NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP NOP<br> STS<span class="Apple-tab-span" style="white-space: pre;"> </span><span class="Apple-tab-span" style="white-space: pre;"> </span>UDR1, R0<br></p> <hr> <p><b><span style="font-size: large;"><br></span></b> <b><span style="font-size: large;">Librería</span></b><br> <br>   La librería está compuesta por una clase pública para el usuario (ArduinoVGA.cpp) y una librería de bajo nivel (ArduinoVGAEngine.cpp) con las rutinas de generación de señal.<br>   La misma es de código abierto (licencia a definir) y puede ser descargada desde la web de <a href="https://sourceforge.net/projects/arduino-vga/" target="_blank" rel="external nofollow noopener">SourceForge</a> desde <a href="https://sourceforge.net/projects/arduino-vga/files/latest/download" target="_blank" rel="external nofollow noopener">aquí</a>.<br> <br> <span style="color: red;"><b><span style="font-size: large;">Importante</span></b></span><br> <span style="color: red;"><b>  (1) Por cuestiones de rendimiento es necesario desactivar el Timer0, utilizado para las rutinas de demora: millis(), micros(), etc. Se provee de una rutina de generación de demoras como reemplazo (VGA.Delay()).</b></span><br> <span style="color: red;"><b>    No es posible utilizar estas rutinas como así tampoco otros periféricos con la generación de interrupciones activa.</b></span><br> <span style="color: red;"><b>    Es una limitación importante de la librería y uno de los costos por no utilizar hardware externo.</b></span><br> <span style="color: red;"><b>  (2) El ~92% del tiempo el microcontrolador estará dedicado a la generación de señales de VGA. Solo en el ~8% restante (denominado “tiempo de blanqueo”) el controlador estará “relativamente liberado” para ejecutar el código de usuario (1,5mS de 16,7ms) así que habrá que “ingeniárselas”.</b></span><br>   <br> <b>Clase pública</b><br></p> <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code style="color: black; word-wrap: normal;">class ArduinoVGA {
  public:
    Init(void);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void PutPixel(unsigned short x, unsigned short y, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void PutPixel(unsigned short x, unsigned short y, unsigned char r, unsigned char g, unsigned char b);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>unsigned char RGB2Color(unsigned char r, unsigned char g, unsigned char b);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void ClrScr(unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void ClrScr(unsigned char r, unsigned char g, unsigned char b);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void ClrScr(void);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Delay(unsigned short ms);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Line(short x0, short y0, short x1, short y1, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Rectangle(short x0, short y0, short x1, short y1, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void FillRectangle(short x0, short y0, short x1, short y1, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Triangle(short x0, short y0, short x1, short y1, short x2, short y2, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Polygon(short x[], short y[], unsigned char vertexCount, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Circle(short x0, short y0, short radius, unsigned char color);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void FontLoad(const unsigned char *font);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void FontColor(unsigned char color, unsigned char backgroundColor);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void GotoXY(unsigned char x, unsigned char y);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Write(char *s);
<span style="font-family: 'Andale Mono', 'Lucida Console', Monaco, fixed, monospace;">    </span>void Write(unsigned char x, unsigned char y, char *s);
};</code>
</pre> <p><b><br></b> <b>Descripción de los métodos</b><br> <br> <b>Init();</b><br> Inicializa la librería.<br> <br> <b>PutPixel(x, y, color);</b><br> Pone un pixel en las coordenadas en pixeles [x, y] de color RGB empaquetado [0..255].<br> <br> <b>PutPixel(x, y, r, g, b);</b><br> Pone un pixel en las coordenadas en pixeles [x, y] de componentes de color r [0..7], g [0..7] y b [0..3].<br> <br> <b>RGB2Color(r, g, b);</b><br> Convierete color de tres componentes [r], [g], [b] a empaquetado de 8 bits [0..255].<br> El formato del empaquetado (byte) será de bit mas significativo a menos significativo [BBGGGRRR].<br> <br> <b>ClrScr(color);</b><br> Borra la pantalla pintando con color RGB empaquetado [0..255].<br> <br> <b>ClrScr(r, g, b);</b><br> Borra la pantalla pintando con color de componentes r [0..7], g [0..7] y b [0..3].<br> <br> <b>ClrScr();</b><br> Borra la pantalla (negro).<br> <br> <b>Delay(ms);</b><br> Genera demora en ms.<br> Como mencionábamos anteriormente, varias de las rutinas estándar de Arduino son desactivadas durante la inicialización de esta librería por cuestiones de rendimiento.<br> <br> <b>Line(x0, y0, x1, y1, color);</b><br> Dibuja línea desde coordenadas en pixeles  [x0, y0] a coordenadas [x1, y1] de color RGB empaquetado [0..255].<br> <br> <b>Rectangle(x0, y0, x1, y1, color);</b><br> Dibuja un rectángulo con coordenadas de vértice superior izquierdo [x0, y0], [x1, y1] de vértice inferior derecho y de color RGB empaquetado [0..255].<br> <br> <b>FillRectangle(x0, y0, x1, y1, color);</b><br> Dibuja un rectángulo relleno con coordenadas de vértice superior izquierdo [x0, y0], [x1, y1] de vértice inferior derecho y de color RGB empaquetado [0..255].<br> <br> <b>Triangle(x0, y0, x1, y1, x2, y2, color);</b><br> Dibuja un triángulo con vértices de coordenadas [x0, y0], [x1, y1] y [x2, y2] de color RGB empaquetado [0..255].<br></p> <div> <br> </div> <p><b>Polygon(x[], y[], vertexCount, color);</b><br></p> <div> Dibuja un polígono de [vertexCount] vértices de coordenadas {[x[0], y[0]] .. [x[vertexCount - 1], y[vertexCount - 1]]} de color RGB empaquetado [0..255].</div> <div> <br> </div> <p><b>Circle(x0, y0, radius, color)</b>;<br> Dibuja circunsferencia con centro en coordenadas en pixeles [x0, y0], radio en pixeles [radius] y color RGB empaquetado [0..255].<br> <br> <b>FontLoad(*font);</b><br> Selecciona fuente [font] almacenada en memoria flash.<br> Se utilizan las fuentes del proyecto <a href="https://code.google.com/p/arduino-tvout/" target="_blank" rel="external nofollow noopener">arduino-tvout</a> ya incluidas dentro de la librería.<br> <br> <b>FontColor(color, backgroundColor);</b><br> Configura color de fuente y color de fondo. Ambos parámetros color RGB empaquetado [0..255].<br> <br> <b>GotoXY(x, y);</b><br> Posiciona puntero de escritura en coordenadas en pixeles [x, y]<br> <b><br></b> <b>Write(char *s);</b><br> Escribe cadena de caracteres en posición de puntero de escritura.<br> Modifica la posición del puntero (permite escribir múltiples cadenas una a continuación de la otra).<br> <br> <b>Write(x, y, *s);</b><br> Escribe una cadena [s] en las coordenadas en pixeles [x, y].<br> Modifica la posición del puntero (permite escribir múltiples cadenas una a continuación de la otra).<br></p> <div> <br> </div> <p><b><span style="font-size: large;">Instalación / </span></b><b><span style="font-size: large;">Utilización</span></b><br>   La instalación es la “clásica” del IDE Arduino:<br>     Menú Programa -&gt; Include Library -&gt; Add .ZIP Library<br>   Para más información consultar la documentación oficial: <a href="http://www.arduino.cc/en/Guide/Libraries#toc4" target="_blank" rel="external nofollow noopener">Installing Additional Arduino Libraries</a><br> <br>   Una vez instalada la librería en el IDE, en un Sketch nuevo o existente se debe proceder con la inclusión de la librería: Programa -&gt; Include Library -&gt; Arduino VGA.<br>   Los métodos de la clase publica están disponibles vía la instancia global VGA. (VGA.PutPixel, VGA.ClrScr, VGA.Line, VGA.Circle, etc).<br> <br> <b>Sketch de ejemplo</b><br></p> <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code style="color: black; word-wrap: normal;">#include &lt;ArduinoVGA.h&gt;
#include &lt;ArduinoVGAConfig.h&gt;
#include &lt;ArduinoVGAEngine.h&gt;
#include &lt;font6x8.h&gt;

// codificado dentro del método setup()
// la librería desactiva varias funcionalidades de Arduino por cuestiones
//de rendimiento.
void setup() {
  // inicialización de la librería
  VGA.Init();
  // carga fuente a utilizar por las rutinas de escritura
  VGA.FontLoad(font6x8);
  // bucle infinito
  while (1){
    // dibuja circulo de radio, posición y aleatoria de la pantalla
    VGA.Circle(random(RX), random(RY), random(10) + 1, random(2));
    // selecciona color de fuente aleatorio y color de fondo negro
    VGA.FontColor(random(2), 0);
    // escribe cadena "Hola mundo!" en posición aleatoria de la pantalla
    VGA.Write(random(RX), random(RY), "Hola mundo!");
  }  
}

// la rutina no se llama nunca en este ejemplo
// jamás se retorna de la rutina setup()
void loop() {
}</code>
</pre> <p><br> <b>Otros ejemplos de uso</b><br> <br>   A continuación un demo para cada uno de los modos.<br>   Ambos forman parte de la librería y pueden ser abiertos como Sketch’s de ejemplo de la librería (Archivo -&gt; Ejemplos -&gt; ArduinoVGA).<br> <br>   <b>VGA Color</b><br>     Para el modo color algunos fractales y un par de efectos de demoscene en resolución 64 x 64 (no puedo mas por cuestiones de RAM).<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/_LDAx8MQrDc/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/_LDAx8MQrDc?feature=player_embedded" width="320"></iframe> </div> <p><br>   Efectos según orden de aparición:<br>     Fuego (básico por cuestiones de RAM)<br>     Fractales<br>       <a href="http://es.wikipedia.org/wiki/Tri%C3%A1ngulo_de_Sierpinski" target="_blank" rel="external nofollow noopener">Sierpisky</a><br>       <a href="http://es.wikipedia.org/wiki/Conjunto_de_Mandelbrot" target="_blank" rel="external nofollow noopener">Mandelbrot</a><br>     Prueba de fuentes<br>     Shadebos<br> <br>   <b>VGA Monocromático</b><br>   Para el modo monocromático programé una librería de <a href="http://es.wikipedia.org/wiki/Gr%C3%A1ficas_tortuga" target="_blank" rel="external nofollow noopener">gráficos de tortuga</a> para nada pulida para hacer algunos fractales recursivos.<br>   La resolución elegida en este caso es de 160 x 120.<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/WqUPCK4U-yc/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/WqUPCK4U-yc?feature=player_embedded" width="320"></iframe> </div> <p><br>   Efectos según orden de aparición:<br>     Fractales<br>       Arbol<br>       <a href="http://es.wikipedia.org/wiki/Curva_del_drag%C3%B3n" target="_blank" rel="external nofollow noopener">Dragón</a><br>       <a href="http://es.wikipedia.org/wiki/Tri%C3%A1ngulo_de_Sierpinski" target="_blank" rel="external nofollow noopener">Sierpisky</a><br>       Koch<br>     Prueba de fuentes<br>     Bolas sobre curvas de <a href="http://es.wikipedia.org/wiki/Curva_de_Lissajous" target="_blank" rel="external nofollow noopener">Lissajous</a><br>     Figuras geométricas<br> <br> <b><span style="font-size: large;">Conclusiones</span></b><br> <br></p> <ul> <li>El resultado es bastante bueno considerando las importantes limitaciones producto de la memoria RAM y la frecuencia de reloj.</li> <li>En modo monocromático cuenta con resolución aceptable y es relativamente utilizable para aplicaciones varias.</li> <li>En modo color es bastante limitado (resolución), es con fines de experimentación y no se le puede pedir mucho mas.</li> <li>Tiene unos cuantos detalles que estimo iré puliendo con el tiempo.</li> </ul> <p><br>   <b>En lo próximo</b><br>     Con la misma idea voy a diseñar un shield con un microcontrolador mas potente (tentativamente algún de la familia ATxmega), memoria RAM onboard y algún que otro chiche, comandado vía SPI por un Arduino y su correspondiente librería de control.<br>     Agregaré alguna que otra función a la librería de interfaz (ArduinoVGA).<br>     Crearé repositorio con el contenido aquí presentado (Sourceforge probablemente).<br>     Trabajaré la librería de bajo nivel (generación de señales) con el fin de exprimir al máximo el hardware y poder mejorar levemente la resolución en los diferentes modos.<br>     Corregiré pequeños detalles de la implementación.<br>     Documentaré el código fuente.<br> <br>   Doy por terminado este artículo, espero el contenido haya sido de utilidad.<br>   Cualquier duda no duden en consultar, nos vemos en la siguiente entrada.<br>   Saludos, Luis.-<br> <br></p> </body></html>