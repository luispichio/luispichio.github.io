<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <div class="separator" style="clear: both; text-align: left;">   Buscando un control para un par de proyectos con Arduino que estoy desarrollando encontré una par de Joystick's de un viejo Clon Family (Dynacom en rigor de verdad) y me parecieron adecuados para la aplicación.</div> <div class="separator" style="clear: both; text-align: left;">   Tratando de encontrar en internet la forma de conexionado y una librería para el manejo me encontré con que no coincidía la información existente con el PinOut del controlador que tenía en mi poder.</div> <div class="separator" style="clear: both; text-align: left;"> <br> </div> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhdAnVLhap9DmzpJwPwNFBR3onp9Obv8dk9kYSK-TlSOO82mV4qLGFNWL5_aC4RilCupAvcMDGymkfeDK7usOCBKCcNYoLcGpcbtkcJAdkDjocyntYlmckszLC813pvldlimsmo4f8pVwTk/s1600/joy9p.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="156" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhdAnVLhap9DmzpJwPwNFBR3onp9Obv8dk9kYSK-TlSOO82mV4qLGFNWL5_aC4RilCupAvcMDGymkfeDK7usOCBKCcNYoLcGpcbtkcJAdkDjocyntYlmckszLC813pvldlimsmo4f8pVwTk/s400/joy9p.gif" width="400"></a> </div> <div class="separator" style="clear: both; text-align: center;"> <br> </div> <div class="separator" style="clear: both; text-align: left;">   Después de desarmar, analizar un poco el circuito (mas detalles abajo para los interesados) y de hacer un "tanteo" logré dar con el PinOut y el protocolo para la lectura de teclas.</div> <div class="separator" style="clear: both; text-align: left;">   Desarrollé una librería (si bien hay alguna que se podría llegar a adaptar me gusta perder tiempo ;)) simple para el manejo.</div> <div class="separator" style="clear: both; text-align: left;"> <br> </div> <div class="separator" style="clear: both; text-align: center;"> <b><span style="font-size: large;"><u>A los bifes</u></span></b> </div> <div class="separator" style="clear: both; text-align: left;"> <br> </div> <div class="separator" style="clear: both; text-align: left;"> <b><span style="font-size: large;">PinOut</span></b> </div> <div class="" style="clear: both; text-align: left;">   Los muchachos que clonaron al NES no se gastaron mucho con respecto; Si bien el PinOut y el conector es distinto, comparten señales con los Joystick clásicos de NES / SNES (supongo empezaron haciendo Joystick's genéricos para las NES :P).</div> <div class="separator" style="clear: both; text-align: left;"> <br> </div> <div style="text-align: center;"> </div> <div style="text-align: center;"> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEilvZFR8G0nIlq6xBf4caQd_Mmt9-7tuMCpeJveyxJBqSPE7uhaoK-Hu8LQt3Pfta3cevwnScqqbdy9VoGuDLkcPGXaJPjSvlme4ZzPiQj5SIWAZKzCWCBFDY2RbSf5e4u9gfuAYjbLJ-XY/s1600/Family+Game+Joystick+-+PinOut.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="300" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEilvZFR8G0nIlq6xBf4caQd_Mmt9-7tuMCpeJveyxJBqSPE7uhaoK-Hu8LQt3Pfta3cevwnScqqbdy9VoGuDLkcPGXaJPjSvlme4ZzPiQj5SIWAZKzCWCBFDY2RbSf5e4u9gfuAYjbLJ-XY/s400/Family+Game+Joystick+-+PinOut.jpg" width="400"></a> </div> <br> </div> <p>  El conector utilizado es un clásico DB9 utilizando solo cinco pines de los nueve; dos para alimentación y tres para señal.<br></p> <div class="" style="clear: both; text-align: left;">   La alimentación (VCC + GND) es de 5V (probé con 3V3 y funcionó perfectamente).</div> <div class="" style="clear: both; text-align: left;">   Con respecto a los pines de señal:</div> <div class="" style="clear: both; text-align: left;">     Latch: Entrada digial que toma el estado de cada botón del controlador (pueden haber varios apretados a la vez) y genera un registro de tantos bits como botones (8).</div> <div class="" style="clear: both; text-align: left;">     Clock: Entrada digital de reloj que produce el desplazamiento del registro de 8bits con el estado de cada botón (1 bit por botón).</div> <div class="" style="clear: both; text-align: left;">     Data: Salida digital. Bit a bit (desplazamiento) del registro de estado de cada botón.</div> <p><br> <b><span style="font-size: large;">Conexionado</span></b><br>   Para el conexionado se pueden utilizar cualquiera de las E/S del Arduino (inclusive las analógicas).<br>   Para el ejemplo utilicé las E/S 49 para Data, 51 para Latch y 53 para el Clock (los pines utilizados se pasan como parámetros de la rutina de inicialización de la librería).<br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRsVmxOfKdgBUp0RGVl33hIJIhSl3q_Raede6KTmZn_v-ijHp3MTaztOHclQ09lVmyTGkSihd5FTH8dv48XD-fdp4d-UmpRbz4BOLvjU5YLtsiDUD0BsSBiuaUbG3Zxc8qHW_sy19Uud4F/s1600/Family+Game+Joystick+-+Conexionado.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="324" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRsVmxOfKdgBUp0RGVl33hIJIhSl3q_Raede6KTmZn_v-ijHp3MTaztOHclQ09lVmyTGkSihd5FTH8dv48XD-fdp4d-UmpRbz4BOLvjU5YLtsiDUD0BsSBiuaUbG3Zxc8qHW_sy19Uud4F/s640/Family+Game+Joystick+-+Conexionado.jpg" width="640"></a> </div> <p><b><span style="font-size: large;">Protocolo</span></b><br>   El protocolo utilizado es el de los Joystick’s NES:<br>     60 veces por segundo, el CPU del NES genera un pulso de 12uS sobre el pin Latch. Esta señal toma el estado de cada botón y el mismo se almacena a razón de 1 bit por botón en un registro de 8 bits.<br>     6 uS después el CPU envía un tren de 8 pulsos de 12uS de período al 50% de duty (6uS de estado bajo + 6uS de estado alto) por el pin Clock.<br>     Sincronizado con el flanco descendiente del pin clock se realiza un <a href="http://es.wikipedia.org/wiki/Registro_de_desplazamiento" target="_blank" rel="external nofollow noopener">desplazamiento del registro</a> de 8 bits por el pin Data. El CPU del NES captura el estado de cada botón leyendo el estado del pin Data en cada flanco ascendente del pin Clock.<br>     Cada botón tiene su “bit” específico.<br> <br>   Lo anteriormente mencionado puede apreciarse en la siguiente figura:<br> <br></p> <div class="separator" style="clear: both; text-align: center;"> <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEirMNabmEvUvP02M1hGP-nl4OoKE5n8B4-okkDdy_CdEAV3R5YYfdtPRf57uLdaQURL_lJOxorRoEoFKjKLT5KzjBkXO57v5fp7x3REGNuC5nMHJJVKoq3GnF7TunQkyxWxoqS5aNa5-LG2/s1600/Family+Game+Joystick+-+Timing.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" rel="external nofollow noopener" target="_blank"><img border="0" height="104" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEirMNabmEvUvP02M1hGP-nl4OoKE5n8B4-okkDdy_CdEAV3R5YYfdtPRf57uLdaQURL_lJOxorRoEoFKjKLT5KzjBkXO57v5fp7x3REGNuC5nMHJJVKoq3GnF7TunQkyxWxoqS5aNa5-LG2/s640/Family+Game+Joystick+-+Timing.jpg" width="640"></a> </div> <p><br>   <b>Notas</b><br>     Es posible presionar múltiples teclas al mismo tiempo sin ningún inconveniente (salida con tantos bits 1 como botones apretados).<br>     Si bien el Joystick tiene 10 botones, 2 de los mismos son “virtuales”. A y B turbo equivalen a la pulsación repetida de los botones A y B respectivamente.<br> <br>   La rutina de “lectura” de teclas es de implementación extremadamente sencilla:<br> <br></p> <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;">unsigned char CheckButtons(void){
  unsigned char buttons = 0;
  unsigned char i;
  digitalWrite(_LatchPin, 1);
  delayMicroseconds(12);
  digitalWrite(_LatchPin, 0);
  for (i = 0 ; i &lt; BUTTON_COUNT ; i++){
    delayMicroseconds(6);
    buttons &lt;&lt;= 1;
    buttons |= digitalRead(_DataPin) ? 0 : 1;
    digitalWrite(_ClockPin, 1);
    delayMicroseconds(6);
    digitalWrite(_ClockPin, 0);
  } 
  return buttons;
}
</pre> <p><br> <b><span style="font-size: large;">Librería</span></b><br>   La librería de control es bien simple; Se trata de una única clase que verifica las teclas pulsadas / presionadas y genera los eventos asociados.<br>   Puede descargarse del <a href="https://sourceforge.net/projects/luispichio/" target="_blank" rel="external nofollow noopener">repositorio de blog</a> desde <a href="https://sourceforge.net/projects/luispichio/files/arduino/FamilyGameJoystick/" target="_blank" rel="external nofollow noopener">aquí</a><br>   Características generales:<br>     No utiliza interrupciones (usa <a href="http://es.wikipedia.org/wiki/Polling" target="_blank" rel="external nofollow noopener">Polling</a>).<br>     Cuenta con Buffer circular de los últimos botones presionados (últimos 16).<br>     Se pueden asociar Callback’s a los eventos de teclas presionadas y pulsadas.<br>     Permite la utilización de múltiples instancias (más de 1 Joystick).<br> <br> <b>Clase pública</b><br></p> <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;">class FamilyGameJoystick {
  public:
    void Init(unsigned char DataPin, unsigned char LatchPin, unsigned char ClockPin);
    void Release(void);
    unsigned char Poll(void);
    bool ButtonDown(unsigned char button);
    bool ButtonPressed(void);
    unsigned char GetButton(void);
    void onButtonDown(void (*function)(unsigned char));
    void onButtonPress(void (*function)(unsigned char));
};
</pre> <p><br> <b>Constantes utilizadas</b><br>   BUTTON_RIGHT<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_LEFT<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_DOWN<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_UP<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_START<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_SELECT<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_B<br> <span class="Apple-tab-span" style="white-space: pre;"> </span>BUTTON_A<br> <br> <b>Descripción de los métodos</b><br> <b><br></b> <span style="font-size: x-small;"><b>void Init(</b><b>unsigned char</b><b> DataPin, </b><b>unsigned char</b><b> ClockPin, </b><b>unsigned char</b><b> LatchPin);</b></span><br> <span style="font-size: x-small;">Rutina de inicialización de la librería.</span><br> <span style="font-size: x-small;">Se pasan como parámetros los pines del Arduino conectados a los pines Data (pin 4 del DB9), Clock (pin 2 del DB9) y Latch (pin 3 del DB9) del Joystick.</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">void Release(void);</span></b><br> <span style="font-size: x-small;">Libera los recursos asociados a la librería (puertos).</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">unsigned char Poll(void);</span></b><br> <span style="font-size: x-small;">Rutina de Polling.</span><br> <span style="font-size: x-small;">Interroga el Joystick en busca de teclas pulsadas y genera los eventos asociados.</span><br> <span style="font-size: x-small;">Debe ser llamada periódicamente desde el bucle principal de la aplicación para el correcto funcionamiento del resto de las rutinas.</span><br> <span style="font-size: x-small;">Puede ser llamada desde una interrupción.</span><br> <span style="font-size: x-small;">Retorna máscara de 8 bits con botones actualmente pulsados utilizando las constantes <span style="white-space: pre;">[B</span>UTTON_RIGHT .. BUTTON_A].</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">bool ButtonDown(unsigned char button);</span></b><br> <span style="font-size: x-small;">Retorna [true] si el / los botones pasados en el parámetro [button] están pulsados.</span><br> <span style="font-size: x-small;">Se entiende “pulsado” como el botón apretado que se mantiene en ese estado mientras se realiza el chequeo.</span><br> <span style="font-size: x-small;">El parámetro [button] es una máscara de 8 bits utilizando las constantes <span style="white-space: pre;">[B</span>UTTON_RIGHT .. BUTTON_A].</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">bool ButtonPressed(void);</span></b><br> <span style="font-size: x-small;">Retorna [true] si hay al menos un botón en el buffer de botones presionados</span><br> <span style="font-size: x-small;">Se entiende como “presionado” a la acción de pulsar y liberar cualquiera de los botones.</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">unsigned char GetButton(void);</span></b><br> <span style="font-size: x-small;">Retorna el primer botón del buffer de botones presionados.</span><br> <span style="font-size: x-small;">El valor retornado se encuentra en el rango <span style="white-space: pre;">[B</span>UTTON_RIGHT .. BUTTON_A].</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">void onButtonDown(void (*function)(unsigned char));</span></b><br> <span style="font-size: x-small;">Registra “callback” de tecla pulsada.</span><br> <span style="font-size: x-small;">La rutina [function] pasada como parámetro se “ejecuta” mientras se mantenga pulsada una o varias teclas.</span><br> <span style="font-size: x-small;">El parámetro pasado a la función se encuentra en el rango <span style="white-space: pre;">[B</span>UTTON_RIGHT .. BUTTON_A].</span><br> <span style="font-size: x-small;"><br></span> <b><span style="font-size: x-small;">void onButtonPress(void (*function)(unsigned char));</span></b><br> <span style="font-size: x-small;">Registra “callback” de tecla presionada.</span><br> <span style="font-size: x-small;">La rutina [function] pasada como parámetro se “ejecuta” cada vez que se presiona (pulsa y libera) una tecla.</span><br></p> <div> <span style="font-size: x-small;">El parámetro pasado a la función se encuentra en el rango <span style="white-space: pre;">[B</span>UTTON_RIGHT .. BUTTON_A].</span> </div> <div> <br> <b>Instalación / Utilización</b><br>   La instalación es la "clásica" del IDE Arduino:<br>     Menú Programa -&gt; Include Library -&gt; Add .ZIP Library<br>   Para más información consultar la documentación oficial: <a href="http://www.arduino.cc/en/Guide/Libraries#toc4" target="_blank" rel="external nofollow noopener">Installing Additional Arduino Libraries</a><br> <br>   Una vez instalada la librería en el IDE, en un Sketch nuevo o existente se debe proceder con la inclusión de la librería: Programa -&gt; Include Library -&gt; FamilyGameJoystick.<br> <br> </div> <p><b>Sketch de ejemplo</b><br>   A continuación un ejemplo simple sin la utilización de eventos.<br>   Este y otros ejemplos se adjuntan con la librería y pueden ser abiertos como Sketch’s de ejemplo de la librería (Archivo -&gt; Ejemplos -&gt; FamilyGameJoystick).<br> <br></p> <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;">#include &lt;FamilyGameJoystick.h&gt;&lt;familygamejoystick .h=""&gt;

//variable global de acceso al Joystick
FamilyGameJoystick Joystick;

void setup() {
  // inicialización del terminal serial
  Serial.begin(9600);
  // rutina de inicialización del Joystick
  // E/S 49 de arduino a pin Data del Joystick 
  // E/S 51 de arduino a pin Latch del Joystick 
  // E/S 53 de arduino a pin Clock del Joystick   
  Joystick.Init(49, 51, 53);
}

//bucle principal de la aplicación
void loop() {
  // se llama a la rutina de Polling
  // la misma establece comunicaciones con el joystick, detecta pulsación de botones, 
  // genera los eventos asociados, etc.
  Joystick.Poll();
  
  //si se presionó un botón (buffer de hasta 16 botones)
  if (Joystick.ButtonPressed()){
    Serial.print("Botón presionado: ");
    // escribimos máscara del botón presionado
    Serial.println(Joystick.GetButton());
  }
  
  //si el botón "izquierda" está siendo pulsado
  if (Joystick.ButtonDown(BUTTON_LEFT)){
    //decrementar la posición X del personaje   
    Serial.println("Izquierda");
  }
    
  //si el botón "derecha" está siendo pulsado
  if (Joystick.ButtonDown(BUTTON_RIGHT)){
    //incrementar la posición X del personaje
    Serial.println("Derecha");    
  }
}
&lt;/familygamejoystick&gt;</pre> <p><br> <b>En lo próximo</b><br>     Generaré otros ejemplos de aplicación (tengo un PacMan a punto de salir del horno).<br>     Implementaré sistema “anti-rebotes” (estimé estaría implementado en el controlador del Joystick / a nivel eléctrico pero me equivoqué).<br>     Corregiré pequeños detalles, documentaré el código fuente, puliré la documentación, etc.<br></p> <div>     Trataré de conseguir Joystick's de otras marcas / modelos (temo que el PinOut difiera).<br> <br> </div> <p>Espero el contenido haya sido de utilidad.<br> Consultas / comentarios son siempre bienvenidos.<br> Nos vemos en la próxima entrada, Saludos!<br> <br></p> </body></html>